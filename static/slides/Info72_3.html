<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Informatique</title>
    <meta charset="utf-8" />
    <meta name="author" content="Pascal Houba" />
    <link href="Info72_3_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="Info72.css" type="text/css" />
    <link rel="stylesheet" href="Info72-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: left, middle, title-slide

# Informatique
## 2020-2021
### Pascal Houba
### <strong>Chapitre 3 : Structures conditionnelles</strong>

---

class:middle

### **Introduction : Une brève histoire de l’informatique**
### **Prologue : Les systèmes de numération**
### **Chapitre 1 : Introduction aux langages de programmation**
### **Chapitre 2 : Premiers pas en _Python_**
### Chapitre 3 : Structures conditionnelles
### **Chapitre 4 : Structures répétitives (1)**
### **Chapitre 5 : Données séquentielles**
### **Chapitre 6 : Structures répétitives (2)**
### **Chapitre 7 : Fonctions**

---

## **Chapitre 3 : Structures conditionnelles**
### 3.1. Les expressions booléennes

Normalement, un programme s'exécute __séquentiellement__, c'est-à-dire ligne par ligne dans l'ordre dans lequel elles se succèdent.

Les __structures conditionnelles__ permettent d'exécuter certaines parties d'un programme selon qu'une ou plusieurs conditions, exprimées sous la forme d'__expressions booléennes__, sont évaluées à `True` ou `False`.

Les expressions booléennes sont formées à l'aide d'__opérateurs relationnels__ ou de fonctions qui renvoient une valeur booléenne, `True` ou `False`.

|Type |Comparaison| Expression booléenne |
|:--|--:|--:|
|Numérique|Egalité |`a == b`|
| |Différence |`a != b`|
| |Inférieur à |`a &lt; b`|
| |Inférieur ou égal à |`a &lt;= b`|
| |Supérieur à |`a &gt; b`|
| |Supérieur ou égal à |`a &gt;= b`|
|Alphanumérique| Egalité |`s1 == s2`|
| | Egalité |`s1.__eq__(s2)`|
| | Ne contient que des chiffres |`s1.isnumeric()`|

---

## **Chapitre 3 : Structures conditionnelles**
### 3.2. Les structures conditionnelles simples


```python
# Début du code séquentiel
# (pas indenté)
```
__Structure `if`__


```python
if condition:
  # Bloc de code à exécuter si l'expression booléenne condition est vraie (True).
  # Attention, l'indentation doit être respectée.
```
.pull-left[
__Structure `if-else` __


```python
if condition:
  # Bloc de code à exécuter si
  # l'expression booléenne
  # condition est vraie (True).
else:
  # Bloc de code à exécuter sinon.
```
]
.pull-right[
__Structure `if-elif-else`__ 


```python
if condition1:
  # Bloc de code à exécuter si
  # l'expression booléenne
  # condition1 est vraie (True).
elif condition2:
  # Bloc de code à exécuter si
  # l'expression booléenne
  # condition2 est vraie (True).
else:
  # Bloc de code à exécuter sinon.
```
]

```python
# Suite du code séquentiel
# (pas indenté)
```

---

## **Chapitre 3 : Structures conditionnelles**
### 3.3. Les structures conditionnelles complexes

__Structure imbriquée__


```python
# Début du code séquentiel
# (pas indenté)

if condition1:
  # Bloc de code à exécuter si condition1 est vraie.
  # Indentation de premier niveau.
  
  if condition2:
    # Bloc de code à exécuter si condition2 est vraie
    # (et condition1 est vraie)
    # Indentation de deuxième niveau.
  else:
    # Bloc de code à exécuter si condition2 est fausse
    # (mais condition1 est vraie)
    # Indentation de deuxième niveau.
    
  # Suite du bloc de code à exécuter si condition1 est vraie.
  # Retour à l'indentation de premier niveau.
else:
  # Bloc de code à exécuter si condition1 est fausse
  # Indentation de premier niveau.

# Suite du code séquentiel
# (pas indenté)
```

---

## **Chapitre 3 : Structures conditionnelles**
### 3.4. Les opérateurs logiques booléens

Lorsque l'on veut combiner plusieurs conditions, il est parfois plus simple d'utiliser des __opérateurs logiques__ plutôt qu'une structure conditionnelle complexe.

Ceux-ci correspondent aux __opérations logiques__ introduites par Boole : __ET, OU, NON__.

En Python, on utilise les mots-clés `and`, `or`, `not` correspondants.

Il est utile de connaître leurs tables d'évaluation :

.pull-left[
| __ET__ |Résultat|
|:--:|:--:|
| Vrai __ET__ Vrai | Vrai|
| Vrai __ET__ Faux | Faux|
| Faux __ET__ Vrai | Faux|
| Faux __ET__ Faux | Faux|
]
.pull-right[
| __OU__ |Résultat|
|:--:|:--:|
| Vrai __OU__ Vrai | Vrai|
| Vrai __OU__ Faux | Vrai|
| Faux __OU__ Vrai | Vrai|
| Faux __OU__ Faux | Faux|
]

et :

| __NON__ |Résultat|
|:--:|:--:|
| __NON__ Vrai | Faux|
| __NON__ Faux | Vrai|


---

## **Chapitre 3 : Structures conditionnelles**
### 3.5. Exercices

__Ex 1.__ Demander à l’utilisateur son nom et son sexe (M ou F). En fonction de ces données, afficher « Cher Monsieur » ou « Chère Mademoiselle » suivi du nom de la personne.

***

__Ex. 2.__ Demander à l’utilisateur qu’il entre un nombre. Afficher ensuite : soit la racine carrée de ce nombre, soit un message indiquant que la racine carrée de ce nombre ne peut être calculée.

***

__Ex. 3.__ Déterminer si une année (dont le millésime est introduit par l’utilisateur) est bissextile ou non. Une année A est bissextile si A est divisible par 4. Elle ne l’est cependant pas si A est un multiple de 100, à moins que A ne soit multiple de 400.

***

__Ex. 4.__ Convertir une note scolaire N quelconque, entrée par l’utilisateur sous forme de points (par exemple 27 sur 85), en une note standardisée suivant le code suivant :

|Note |Appréciation|
|:--|--:|
|N &gt;= 80%|A |
|80% &gt; N &gt;= 60% |B |
|60% &gt; N &gt;= 50% |C |
|50% &gt; N &gt;= 40% |D |
|N &lt; 40%|E |
---

## **Chapitre 3 : Structures conditionnelles**
### 3.5. Correctifs des exercices

__Ex 1.__ Demander à l’utilisateur son nom et son sexe (M ou F). En fonction de ces données, afficher « Cher Monsieur » ou « Chère Mademoiselle » suivi du nom de la personne.


```python
nom = input("Quel est votre nom? ")
sexe = input("Quel est votre sexe (M/F) ? ")

if sexe == "M":
    print("Cher Monsieur "+nom)
else:
    print("Chère Mademoiselle "+nom)
```
***
Version inclusive

```python
nom = input("Quel est votre nom? ")
sexe = input("Quel est votre sexe (M/F/X) ? ")

if sexe == "M":
    print("Cher Monsieur "+nom)
elif sexe == "F":
    print("Chère Mademoiselle "+nom)
else:
    print("Cher.e "+nom)
```

---

## **Chapitre 3 : Structures conditionnelles**
### 3.5. Correctifs des exercices


__Ex 2.__ Demander à l’utilisateur qu’il entre un nombre. Afficher ensuite : soit la racine carrée de ce nombre, soit un message indiquant que la racine carrée de ce nombre ne peut être calculée.


```python
from math import sqrt

saisie = input("Entrez un nombre dont vous voulez connaître la racine carrée : ")
nombre = float(saisie)

if nombre &gt;= 0:
    print("La racine carrée de " + saisie + " est " + str(sqrt(nombre)))
else:
    print("La racine carrée de " + saisie + " n'existe pas dans les réels.")
```
---

## **Chapitre 3 : Structures conditionnelles**
### 3.5. Correctifs des exercices

__Ex. 3.__ Déterminer si une année (dont le millésime est introduit par l’utilisateur) est bissextile ou non. Une année A est bissextile si A est divisible par 4. Elle ne l’est cependant pas si A est un multiple de 100, à moins que A ne soit multiple de 400.

__Version avec structure imbriquée__

```python
a = int(input("Entrez le millésime de l'année (AAAA) : "))

if a % 4 == 0:
    if a % 100 == 0:
        if a % 400 == 0:
            # a est divisible par 400
            print(str(a) + " est bissextile")
        else:
            # a est divisible par 100 mais pas par 400
            print(str(a) + " n'est pas bissextile")
    else:
        # a est divisible par 4 mais pas par 100
        print(str(a) + " est bissextile")
else:
   # a n'est pas divisible par 4
   print(str(a) + " n'est pas bissextile")
```
---

## **Chapitre 3 : Structures conditionnelles**
### 3.5. Correctifs des exercices

__Ex. 3.__ Déterminer si une année (dont le millésime est introduit par l’utilisateur) est bissextile ou non. Une année A est bissextile si A est divisible par 4. Elle ne l’est cependant pas si A est un multiple de 100, à moins que A ne soit multiple de 400.

__Version avec opérateurs logiques__


```python
a = int(input("Entrez le millésime de l'année (AAAA) : "))

if a%4 == 0 and a%100 == 0 and a%400 == 0:
    print(str(a) + " est bissextile") 
elif a%4 == 0 and a%100 != 0:
    print(str(a) + " est bissextile")
else:
   print(str(a) + " n'est pas bissextile")
```
---

## **Chapitre 3 : Structures conditionnelles**
### 3.5. Correctifs des exercices

__Ex. 4.__ Convertir une note scolaire N quelconque, entrée par l’utilisateur sous forme de points (par exemple 27 sur 85), en une note standardisée.


```python
points = float(input("Entrez votre note chiffrée : "))
total = int(input("Entrez le total sur lequel vous êtes noté : "))

pourcentage = points/total*100

# Traduction du pourcentage en une appréciation A-E selon un barême
if pourcentage &gt;= 80:
    cote = "A"
elif pourcentage &gt;= 60 and pourcentage &lt; 80:
    cote = "B"
elif pourcentage &gt;= 50 and pourcentage &lt; 60:
    cote = "C"
elif pourcentage &gt;= 40 and pourcentage &lt; 50:
    cote = "D"
elif pourcentage &lt; 40:
    cote = "E"
    
print("Vous avez obtenu le pourcentage de "+str(pourcentage)+" %.")
print("Cela correspond à une cote de "+cote+".")
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>

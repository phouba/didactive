<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Informatique</title>
    <meta charset="utf-8" />
    <meta name="author" content="Pascal Houba" />
    <link href="Info72_5_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="Info72.css" type="text/css" />
    <link rel="stylesheet" href="Info72-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: left, middle, title-slide

# Informatique
## 2020-2021
### Pascal Houba
### <strong>Chapitre 5 : Données séquentielles</strong>

---

class:middle

### **Introduction : Une brève histoire de l’informatique**
### **Prologue : Les systèmes de numération**
### **Chapitre 1 : Introduction aux langages de programmation**
### **Chapitre 2 : Premiers pas en Python**
### **Chapitre 3 : Structures conditionnelles**
### **Chapitre 4 : Structures répétitives (1)**
### Chapitre 5 : Données séquentielles
### **Chapitre 6 : Structures répétitives (2)**
### **Chapitre 7 : Fonctions**

---

## **Chapitre 5 : Données séquentielles**
### 5.1. Les listes

#### 1. Définition

Les listes sont des __séquences__, c’est-à-dire des collections ordonnées d’objets toujours disposés __dans le même ordre__.

On peut __définir une liste__ comme une collection d’éléments séparés par des virgules, l’ensemble étant enfermé dans des crochets.


```python
jour = ['lundi', 'mardi', 'mercredi', 1800, 20.357, 'jeudi', 'vendredi']
```

Les éléments individuels qui constituent une liste peuvent être de __types variés__ (ce qui n'est généralement pas le cas pour des types de données similaires dans d'autre langages, comme les tableaux en _Java_).

Les __chaînes de caractères__ (_string_) que nous avons abordées au chapitre 2 constituaient un premier exemple de données séquentielles.

---

## **Chapitre 5 : Données séquentielles**
### 5.1. Les listes

#### 2. Indiçage

On peut accéder à chaque élément d'une liste si l’on connaît __son index__ (en commençant __à partir de zéro__, et non à partir de un).


```python
liste          : ['girafe', 'tigre', 'singe', 'souris']
indice positif :        0        1        2         3
indice négatif :       -4       -3       -2        -1
```

***

Une partie des exemples de ce chapitre proviennent du cours en ligne "Introduction à la programmation Python pour la biologie" de Patrick Fuchs et Pierre Poulain, accessible à l'adresse https://python.sdv.univ-paris-diderot.fr

***

---

## **Chapitre 5 : Données séquentielles**
### 5.1. Les listes

#### 3. Découpage (_slicing_)

On peut sélectionner une partie d'une liste en utilisant un indiçage construit sur le modèle `[m:n]` pour récupérer les éléments de l'élément `m` à l'élément `n` :


```python
animaux = ['girafe', 'tigre', 'singe', 'souris']
animaux[0:2]
&gt; ['girafe', 'tigre']
```
Notez que lorsqu'aucun indice n'est indiqué à gauche ou à droite du symbole deux-points, Python prend par défaut tous les éléments depuis le début ou tous les éléments jusqu'à la fin respectivement.


```python
animaux[1:]
&gt; ['tigre', 'singe', 'souris']
animaux[:]
&gt; ['girafe', 'tigre', 'singe', 'souris']
```

On peut aussi préciser le pas en ajoutant un symbole deux-points supplémentaire et en indiquant le pas par un entier, sur le modèle `liste[début:fin:pas]`.


```python
animaux[0:3:2]
&gt; ['girafe', 'singe']
```

---

## **Chapitre 5 : Données séquentielles**
### 5.1. Les listes

#### 4. Opérations

Tout comme les chaînes de caractères, les listes supportent l'opérateur `+` de __concaténation__, ainsi que l'opérateur `*` pour la __duplication__ :


```python
ani1 = ['girafe', 'tigre']
ani2 = ['singe', 'souris']
ani1 + ani2
&gt; ['girafe', 'tigre', 'singe', 'souris']

ani1 * 3
&gt; ['girafe', 'tigre', 'girafe', 'tigre', 'girafe', 'tigre']
```

#### 5. Modifications

Mais à la différence de ce qui se passe pour les chaînes, il est possible de changer les éléments individuels d’une liste :


```python
jour = ['lundi', 'mardi', 'mercredi', 1800, 20.357, 'jeudi', 'vendredi']
jour[2] = 'Juillet'
jour[3] = jour[3] + 47
print(jour)
&gt; ['lundi', 'mardi', 'Juillet', 1847, 20.357, 'jeudi', 'vendredi']
```

---

## **Chapitre 5 : Données séquentielles**
### 5.1. Les listes

#### 6. Fonctions et méthodes

La fonction intégrée `len()`, que nous avons déjà rencontrée à propos des chaînes, s’applique aussi aux listes. Elle renvoie le nombre d’éléments présents dans la liste :


```python
jour = ['lundi', 'mardi', 'Juillet', 1847, 20.357, 'jeudi', 'vendredi']
print(len(jour))
&gt; 7
```

Une autre fonction intégrée permet de supprimer d’une liste un élément quelconque (à partir de son
index). Il s’agit de la fonction `del()` :


```python
del(jour[4])
print(jour)
&gt; ['lundi', 'mardi', 'Juillet', 1847, 'jeudi', 'vendredi']
```

Pour ajouter un élément à une liste, il faut considérer que la liste est un __objet__, dont on va utiliser l’une des __méthodes__, `append()`, en reliant les deux à l’aide d’un __point__.


```python
jour.append('samedi')
print(jour)
&gt; ['lundi', 'mardi', 'Juillet', 1847, 'jeudi', 'vendredi', 'samedi']
```
---

## **Chapitre 5 : Données séquentielles**
### 5.1. Les listes

#### 7. Fonctions `range()` et `list()`

L'instruction `range()` est une fonction spéciale en _Python_ qui génère des nombres entiers compris dans un intervalle. Lorsqu'elle est utilisée en combinaison avec la fonction `list()`, on obtient une liste d'entiers. Par exemple :


```python
list(range(10))
&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

La fonction range() peut également prendre deux ou trois arguments sur le modèle `range([début,] fin[, pas])` :


```python
list(range(0, 5))
&gt; [0, 1, 2, 3, 4]
list(range(15, 20))
&gt; [15, 16, 17, 18, 19]
list(range(0, 1000, 200))
&gt; [0, 200, 400, 600, 800]
list(range(2, -2, -1))
&gt; [2, 1, 0, -1]
```

---

## **Chapitre 5 : Données séquentielles**
### 5.1. Les listes

#### 8. Fonctions minimum, maximum et somme

Les fonctions `min()`, `max()` et `sum()` renvoient respectivement le minimum, le maximum et la somme d'une liste passée en argument.


```python
liste = list(range(10))
liste
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
sum(liste)
&gt; 45
min(liste)
&gt; 0
max(liste)
&gt; 9
```

---

## **Chapitre 5 : Données séquentielles**
### 5.1. Les listes

#### 9. Listes de listes

Pour finir, sachez qu'il est possible de construire des listes de listes. Par exemple :


```python
enclos1 = ['girafe', 4]
enclos2 = ['tigre', 2]
enclos3 = ['singe', 5]
zoo = [enclos1, enclos2, enclos3]
zoo
&gt; [['girafe', 4], ['tigre', 2], ['singe', 5]]
```

Pour accéder à un élément de la liste, on utilise l'indiçage habituel :


```python
zoo[1]
&gt; ['tigre', 2]
```

Pour accéder à un élément de la sous-liste, on utilise un double indiçage :


```python
zoo[1][0]
&gt; 'tigre'
zoo[1][1]
&gt; 2
```



---

## **Chapitre 5 : Données séquentielles**
### 5.1. Les listes

#### 10. Exercices

__1.__ Reprendre l'exercice n°9 du chapitre précédent en utilisant une liste et les fonctions sur les listes.


```python
# Déclaration des variables
note = 0
notes = [] # Liste de notes (vide au départ)
# Boucle
while note &gt;= 0:
    note = float(input("Entrez une note : "))
    if note &gt;= 0:
        notes.append(note) # Ajout de la dernière note à la liste de notes
        n = len(notes) # Nombre de notes jusqu'à présent
        print("Note n°"+str(n) + " : " + str(note))
        print("Liste des notes : "+str(notes))
        moyenne = sum(notes)/n
        print("Moyenne : "+str(moyenne))
        minimum = min(notes)
        print("Minimum : "+str(minimum))
        maximum = max(notes)
        print("Maximum : "+str(maximum))
        print("-------------")
```
---

## **Chapitre 5 : Données séquentielles**
### 5.1. Les listes

#### 10. Exercices

__2.__ Construire un calendrier grâce aux listes.

Définir des listes pour les noms des jours de la semaine, le nom des mois et leurs nombre de jour (commencer par supposer une année non-bissextile).

Le programme doit demander le nom du jour du 1er janvier et construire le reste de l'année à partir de là.

Deux listes seront produites : une avec les 365 jours de l'année et une autre contenant les listes de chaque semaine (une liste de listes donc).

Cette dernière liste sera affichée à la manière d'un calendrier mural.

Astuce : On peut trouver l'index d'un élément `x` dans une liste en utilisant la méthode `list.index(x)`.

---

## **Chapitre 5 : Données séquentielles**
### 5.1. Les listes

#### 10. Exercices

__2.__ Construire un calendrier grâce aux listes.


```python
jours = ["Lun", "Mar", "Mer", "Jeu", "Ven", "Sam", "Dim"]
mois = ["Jan", "Fév", "Mars", "Avr", "Mai", "Juin", "Juil", "Août", "Sept", "Oct", "Nov", "Déc"]
joursParMois = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

debut = input("Entrer le nom du jour de la semaine du 1er janvier : ")
if debut in jours: # Vérifie que le nom entré est bien dans les liste des jours
    joursAnnee = jours*54 # Tous les noms des jours de l'année et plus...

    iDebut = jours.index(debut) # index du nom du premier jour de l'année
    joursAnnee = joursAnnee[iDebut:] # On commence à l'index du premier jour
    joursAnnee = joursAnnee[:365] # On prend les 365 premiers jours

    calendrier = [] # Liste des 365 jours de l'année avec leur date
```

(suite à la page suivante)

---

## **Chapitre 5 : Données séquentielles**
### 5.1. Les listes

#### 10. Exercices

__2.__ Construire un calendrier grâce aux listes.

Deux possibilités pour construire la liste `calendrier` :


```python
    # Version avec une simple boucle
    n = 0 # index du mois
    i = 0 # index du jour
    calendrier = []
    for j in joursAnnee:
        date = j + " " + str(i+1) + " " + mois[n] # Date complète
        calendrier.append(date)
        i = i + 1
        if (i == joursParMois[n]): # Dernier jour du mois ?
            i = 0
            n = n + 1
```


```python
    # Version avec une double boucle
    i = 0 # Numéro du jour de l'année : 0 -&gt; 364
    for n, m in enumerate(mois): # n contient l'index du mois, m le nom du mois
        for j in range(joursParMois[n]): # Parcourt les numéros des jours du mois
            date = joursAnnee[i] + " " + str(j+1) + " " + m # Date complète
            calendrier.append(date)
            i = i + 1
```

(suite à la page suivante)
---

## **Chapitre 5 : Données séquentielles**
### 5.1. Les listes

#### 10. Exercices

__2.__ Construire un calendrier grâce aux listes.


```python
    semainier = [] # Liste des semaines
    semaine = [] # Chaque semaine
    for i, d in enumerate(calendrier):
        semaine.append(d)
        if joursAnnee[i] == jours[-1]: # Dernier jour de la semaine (dimanche) ?
            semainier.append(semaine)
            semaine = []
    semainier.append(semaine)
      # Ajoute la semaine incomplète qui n'aurait pas atteint le dimanche
    
    # Affichage par semaine
    largeurColonne = 26 # A adapter selon la largeur de l'écran
    for i in range(iDebut): # Affichage du début de la première semaine (espaces)
        print(' '*largeurColonne, end='') # Ne pas retourner à la ligne
        
    for s in semainier:
        for j in s:
            print(j+' '*(largeurColonne-len(j)), end='')
                # Affiche toujours le même nombre de caractères par colonne
                # Ne pas retourner à la ligne
        print('\n') # Retour à la ligne après chaque semaine
```

---

## **Chapitre 5 : Données séquentielles**
### 5.2. Les tuples

Les __tuples__ (« n-tuplets » en français) correspondent aux listes à la différence qu'ils sont __non modifiables__. Ils utilisent les parenthèses au lieu des crochets :


```python
x = (1, 2, 3)
x
&gt; (1, 2, 3)

x[2]
&gt; 3

x[0:2]
&gt; (1, 2)

x[2] = 15
&gt; Traceback (innermost last):
File "&lt;stdin&gt;", line 1, in ?
TypeError: object doesn't support item assignment
```

Pour utiliser un tuple d'un seul élément, vous devez utiliser une syntaxe avec une virgule `(element,)`, ceci pour éviter une ambiguïté avec une simple expression.
---


## **Chapitre 5 : Données séquentielles**
.pull-left[
### 5.1. Les listes
]
.pull-right[
### 5.2. Les tuples
]
.center[
&lt;iframe width="800" height="450" src="https://www.youtube.com/embed/watch?v=5UOSiCPu5aM&amp;list=PLO_fdPEVlfKqMDNmCFzQISI2H_nJcEDJq&amp;index=4" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;
]

---

## **Chapitre 5 : Données séquentielles**
### 5.3. Les dictionnaires

Les dictionnaires sont des collections __non ordonnées__ d'objets (donc pas d'indice). On accède aux __valeurs__ d'un dictionnaire par des __clés__.


```python
ani1 = {}
ani1["nom"] = "girafe"
ani1["taille"] = 5.0
ani1["poids"] = 1100
ani1
&gt; {'nom': 'girafe', 'taille': 5.0, 'poids': 1100}
```

On peut aussi initialiser toutes les clés et les valeurs d'un dictionnaire en une seule opération :


```python
ani2 = {"nom":"singe", "poids":70, "taille":1.75}
```

On peut également ajouter une clé et une valeur supplémentaire :


```python
ani2["age"] = 15
```

Pour récupérer la valeur associée à une clé donnée, il suffit d'utiliser la syntaxe suivante :


```python
ani1["taille"]
&gt; 5.0
```

---

## **Chapitre 5 : Données séquentielles**
### 5.3. Les dictionnaires

Les méthodes `.keys()` et `.values()` renvoient les clés et les valeurs d'un dictionnaire :


```python
ani2.keys()
&gt; dict_keys(['poids', 'nom', 'taille'])
ani2.values()
&gt; dict_values([70, 'singe', 1.75])
```

Les mentions `dict_keys` et `dict_values` indiquent que nous avons à faire à des objets un peu particuliers. Ils ne sont pas indexables (on ne peut pas retrouver un élément par indice, par exemple `dico.keys()[0]` renverra une erreur). Si besoin, nous pouvons les transformer en liste avec la fonction `list()` :



```python
list(ani2.values())
&gt; [70, 'singe', 1.75]
```

Il existe aussi la méthode `.items()` qui renvoie un nouvel objet `dict_items` :


```python
dico = {0: 't', 1: 'o', 2: 't', 3: 'o'}
dico.items()
&gt; dict_items([(0, 't'), (1, 'o'), (2, 't'), (3, 'o')])
```

---

## **Chapitre 5 : Données séquentielles**
### 5.3. Les dictionnaires

Pour vérifier si une clé existe dans un dictionnaire, on peut utiliser le test d’appartenance avec l'instruction `in` (et `not in`) qui renvoie un booléen :


```python
if "poids" in ani2:
    print("La clé 'poids' existe pour ani2")

if "age" not in ani2:
     print("La clé 'age' n'existe pas pour ani2")
```

***
.center[
&lt;iframe width="500" height="275" src="https://www.youtube.com/embed/watch?v=QR-gUWAeLqs&amp;list=PLO_fdPEVlfKqMDNmCFzQISI2H_nJcEDJq&amp;index=5" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;
]
---

## **Chapitre 5 : Données séquentielles**
### 5.3. Les dictionnaires

#### Exercice

Appliquer ce programme pour trouver les fréquence d'apparition des chiffres dans les premières décimales de _pi_.


```python
texte = "Un petit texte quelconque."
occurrences = {} # Dictionnaire vide
for c in texte: # Parcourt tous les caractères de la chaîne 'texte'
    if c in occurrences:
        occurrences[c] += 1 # Incrémenter la valeur de la clé c
    else:
        occurrences[c] = 1 # Crée un élément avec la clé c
print(occurrences)
```
---

## **Chapitre 5 : Données séquentielles**
### 5.3. Les dictionnaires

#### Exercice

Appliquer le programme précédent pour trouver les fréquence d'apparition des chiffres dans les premières décimales de _pi_.


```python
from mpmath import mp
mp.dps = 400 # nombre de décimales

texte = str(mp.pi)[2:] # On ne retient que les décimales
occurrences = {} # Dictionnaire vide
for c in texte: # Parcourt tous les caractères de la chaîne 'texte'
    if c in occurrences:
        occurrences[c] += 1 # Incrémenter la valeur de la clé c
    else:
        occurrences[c] = 1 # Crée un élément avec la clé c
print(occurrences)
```

---

## **Annexe**
### Accès à des sources de données sur _Kaggle_

Trouver le nom et le chemin des fichiers de données liés à un notebook Kaggle :


```python
import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))
```

Ouverture d'un fichier de type `csv` (_Comma Separated Values_ : valeurs séparées par des virgules, ou d'autres caractères de séparation comme le point-virgule ou la tabulation) :


```python
import csv

with open(os.path.join(dirname, filename)) as file:
    dataDR = csv.DictReader(file) # Objet de type DictReader
    
    header = dataDR.fieldnames # Liste des champs (entêtes des colonnes)
    print(header)
```

`DictReader` est un objet du module `csv` qui aide à accéder aux données du fichier via une structure proche d'un dictionnaire. Un de ses attributs est `fieldname` qui permet de trouver la liste des noms des __champs__ (entêtes des colonnes).

---

## **Chapitre 5 : Données séquentielles**
### 5.3. Les dictionnaires

#### Exercice : analyser les données du _dataset_ _"Netflix Movies and TV Shows"_.

La plateforme _Kaggle_ met a disposition un grand nombre de _datasets_. Parmis ceux-ci, on peut en trouver un qui contient des données sur des shows (films et émissions de télévision) accessibles sur la plateforme de streaming _Netflix_.

Vous devez créer un _notebook Kaggle_ avec un lien vers cette _source de données_.

Ensuite, accédez aux données via le code de la page précédente (le début du code est déjà écrit dans le nouveau _notebook Kaggle_). Avec ses données, effectuez les opérations suivantes :

__a)__ Trouver la liste des champs du fichier

__b)__ Trouver le nombre de shows listés dans le fichier

__c)__ Imprimer une liste de 10 shows et leur date de sortie

__d)__ Trouver le nombre de films sortis en 2020

__e)__ Construire une liste qui contient les années de sorties des shows

__f)__ Construire une liste des titres des films sortis en 2020

__g)__ Construire un dictionnaire contenant la liste des années et le nombre de shows de chaque année

__h)__ Trouver l'année où le maximum de shows sont sortis

---

## **Chapitre 5 : Données séquentielles**
### 5.3. Les dictionnaires

#### Correctif : analyser les données du _dataset_ _Netflix Movies and TV Shows_. (1/4)


```python
import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

import csv
with open(os.path.join(dirname, filename)) as file:
    dataDR = csv.DictReader(file) # Objet de type DictReader
    
    # a) Trouver la liste des champs du fichier
    header = dataDR.fieldnames # Liste des champs (entêtes des colonnes)
    print(header)
    print("-------")
    
    # b) Trouver le nombre de shows listés dans le fichier
    dataL = list(dataDR)
    print(len(dataL), "shows")
    print("-------")
    
    # c) Imprimer une liste de 10 shows et leur date de sortie
    for i in dataL[1000:1010]:
        print(i['title'],'('+i['release_year']+')')
    print("-------")
```

(suite à la page suivante)
---

## **Chapitre 5 : Données séquentielles**
### 5.3. Les dictionnaires

#### Correctif : analyser les données du _dataset_ _Netflix Movies and TV Shows_. (2/4)


```python
    # d) Trouver le nombre de films sortis en 2020
    n2020 = 0 # Compteur
    for i in dataL: # Parcourt tous les shows
        if i['release_year'] == '2020': # Si l'année de sortie est 2020
            n2020 += 1 # On incrémente le compteur
    print(n2020, "shows sortis en 2020")
    print("-------")
    
    # e) Construire une liste qui contient les années de sorties des shows
    annees = [] # Liste vide
    for i in dataL: # Parcourt tous les shows
        if i['release_year'] not in annees:
            # Si l'année de sortie n'est pas déjà dans la liste
            annees.append(i['release_year']) # On l'ajoute dans la liste
    annees.sort() # Tri
    print(annees)
    print("-------")
```
(suite à la page suivante)
---

## **Chapitre 5 : Données séquentielles**
### 5.3. Les dictionnaires

#### Correctif : analyser les données du _dataset_ _Netflix Movies and TV Shows_. (3/4)


```python
    # f) Construire une liste des titres des films sortis en 2020
    films2020 = [] # Liste vide
    for i in dataL: # Parcourir la liste des shows
        if i['release_year'] == '2020' and i['type'] == 'Movie':
            # Si l'année de sortie du film est 2020
            films2020.append(i['title']) # On ajoute le titre à la liste
    print(films2020[-10:]) # On affiche les dix derniers
    print("------")
    
    # g) Construire un dictionnaire contenant la liste des années
    #    et le nombre de shows de chaque année
    parAnnees = {} # Dictionnaire vide
    for i in dataL: # Parcourt tous les shows
        if i['release_year'] not in parAnnees:
            # Si l'année de sortie n'est pas déjà dans le dictionnaire
            parAnnees[i['release_year']] = 1
                # On crée un nouvel élément dont la clé est l'année de sortie 
                # et la valeur est 1
        else: # Sinon (l'année de sortie est déjà dans le dictionnaire)
            parAnnees[i['release_year']] += 1
                # On incrémente la valeur correspondant
                # à la clé de l'année de sortie
    print(parAnnees)
    print("-------")
```
(suite à la page suivante)
---

## **Chapitre 5 : Données séquentielles**
### 5.3. Les dictionnaires

#### Correctif : analyser les données du _dataset_ _Netflix Movies and TV Shows_. (4/4)


```python
    # h) Trouver l'année où le maximum de shows sont sortis
    #    (à partir du dictionnaire construit précédemment)
    cles = list(parAnnees.keys()) # La liste des clés (années de sorties)
    valeurs = list(parAnnees.values()) # La liste des valeurs (nombre de sorties)
    nmax = max(valeurs) # Trouve la valeur maximum
    print("Un maximum de", nmax, "films sont sortis la même année.")
    
    # Attention : cette année n'est pas obligatoirement unique!
```

```python
    # h') On suppose que cette année est unique
    imax = valeurs.index(nmax) # Trouve l'index correspondant à cette valeur
    ymax = cles[imax] # Trouve la clé correspondant à cet index
    print("C'était en",ymax)
```

```python
    # h'') Construire une liste des clés pour lesquelles la valeur est maximum
    lmax = [] # Liste vide
    for e in parAnnees: # Parcourt toutes les années
        if parAnnees[e] == nmax: # Si la valeur de cette année est maximum
            lmax.append(e); # On l'ajoute à la liste
    print("Les années où un maximum de films sont sortis sont",lmax) 
```

---

## **Chapitre 5 : Données séquentielles**
### 5.4. Les tableaux

Les tableaux n'existent pas en _Python_ standard. Pour pouvoir les utiliser, on doit y accéder via le module _NumPy_

Contrairement aux listes, les tableaux _NumPy_ ne peuvent contenir qu'un seul type de données à la fois.

On peut créer un tableau _NumPy_ à partir d'une liste (en spécifiant explicitement ou non le type de données avec le paramètre `dtype`) :


```python
import numpy as np

t_int = np.array([1, 4, 2, 5, 3]) # Tableau d'entiers

t_float = np.array([3.14, 4, 2, 3]) # Tableau de flottants

t_float32 = np.array([1, 2, 3, 4], dtype='float32')
  # Tableau de flottants sur 32 bits

t_2D = np.array([[1,2,3],[3,4,5],[6,7,8]]) # Tableau à 2 dimensions
```
---

## **Chapitre 5 : Données séquentielles**
### 5.4. Les tableaux

#### Méthodes

Il existe aussi plusieurs __méthodes__ (fonctions orientées objet) _NumPy_ pour créer directement des tableaux de différentes sortes :


```python
t0 = np.zeros(10, dtype=int) # Un tableau de 10 entiers rempli de zéros

t1 = np.ones((3, 5), dtype=float)
  # Un tableau de flottants à 2 dimensions de taille 3x5 rempli de uns
  
tpi = np.full((3, 5), 3.14) # Un tableau de taille 3x5 rempli de 3.14

ts = np.arange(0, 20, 2) # Un tableau contenant une séquence linéaire
  # commençant à 0 et allant jusque 20 par pas de 2

tl = np.linspace(0, 1, 5)
  # Un tableau de 5 nombres espacés linéairement entre 0 et 1

taf = np.random.random((3, 3))
  # Un tableau de taille 3x3 rempli de flottants aléatoires entre 0 et 1
  
tai = np.random.randint(5, 11, size=(3, 3))
  # Un tableau de taille 3x3 rempli d'entiers aléatoires entre 5 et 10

tid = np.eye(3) # La matrice identité de taille 3x3
```
---

## **Chapitre 5 : Données séquentielles**
### 5.4. Les tableaux

#### Attributs

Les tableaux _NumPy_ possèdent également plusieurs __attributs__ (propriétés orientées objet) utiles :

- `.ndim` pour le nombre de dimensions

- `.shape` pour les dimensions

- `.size` pour le nombre d'éléments

- `.dtype` pour le type des éléments

#### Indiçage et découpage

On peut accéder aux éléments ou à des parties de tableaux avec les mêmes techniques d'indiçage et de découpage que pour les listes.

#### Changement de forme

La méthode `reshape` permet changer les __dimensions__ (`shape`) d'un tableau.


```python
np.array([1,2,3,4,5,6]).reshape(3,2)
```

---

## **Chapitre 5 : Données séquentielles**
### 5.4. Les tableaux

#### Méthodes mathématiques

_NumPy_ contient un grand nombre de fonctions mathématiques. Cependant elles diffèrent de celles que l'on peut trouver dans le module _math_ car elles s'appliquent à tous les éléments des tableaux à la fois.


```python
import numpy as np 
a = np.array([0,30,45,60,90]) 
print 'Sinus de quelques angles:' 
print np.sin(a*np.pi/180) # Conversion en radiants en multipliant par pi/180
&gt; Sinus de quelques angles:
[ 0.          0.5         0.70710678  0.8660254   1.        ]
```
***
.pull-left[
&lt;iframe width="400" height="225" src="https://www.youtube.com/embed/watch?v=2LdLiCtVUEA&amp;list=PLO_fdPEVlfKqMDNmCFzQISI2H_nJcEDJq&amp;index=9" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;
]
.pull-right[
&lt;iframe width="400" height="225" src="https://www.youtube.com/embed/watch?v=NzDQTrqsxas&amp;list=PLO_fdPEVlfKqMDNmCFzQISI2H_nJcEDJq&amp;index=10" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;
]

---

## **Chapitre 5 : Données séquentielles**
### 5.4. Les tableaux

#### Exercices interactifs (1/6)

a) Importer Numpy


```python
import numpy as np
```

b) Créer un tableau contenant 5 zéros


```python
np.zeros(5)
```

```
## array([0., 0., 0., 0., 0.])
```

c) Créer un tableau de 15 éléments valant 7


```python
#np.zeros(15) + 7
#np.ones(15) * 7
np.full(15,7)
```

```
## array([7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7])
```
---

## **Chapitre 5 : Données séquentielles**
### 5.4. Les tableaux

#### Exercices interactifs (2/6)
d) Créer un tableau d'entiers entre 5 et 10


```python
np.arange(5,11)
```

```
## array([ 5,  6,  7,  8,  9, 10])
```
e) Créer un tableau de tous les entiers impairs entre 0 et 10


```python
#np.arange(0,10,2) + 1
#np.arange(1,11,2)
impairs = np.arange(0,11)
impairs[impairs % 2 == 1]
```

```
## array([1, 3, 5, 7, 9])
```

f) Créer une matrice 3x3 avec les valeurs de 1 à 9

```python
np.arange(1,10).reshape(3,3)
```

```
## array([[1, 2, 3],
##        [4, 5, 6],
##        [7, 8, 9]])
```
---

## **Chapitre 5 : Données séquentielles**
### 5.4. Les tableaux

#### Exercices interactifs (3/6)
g) Créer une matrice de 5 éléments dont les valeurs sont des flottants aléatoires entre 0 et 10


```python
np.random.random(5)*10
```

```
## array([6.39917054, 9.51029374, 9.98294261, 5.37318423, 8.80672531])
```

h) Créer un tableau qui contient les valeurs suivantes:

0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.


```python
#np.linspace(0.1,1,10)
np.arange(0.1,1,0.1)
```

```
## array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
```

---

## **Chapitre 5 : Données séquentielles**
### 5.4. Les tableaux

#### Exercices interactifs (4/6)
i) Créer une variable contenant la matrice suivante :

array([[ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12], [13, 14, 15, 16]])


```python
mat = np.arange(1,17).reshape(4,4)
mat
```

```
## array([[ 1,  2,  3,  4],
##        [ 5,  6,  7,  8],
##        [ 9, 10, 11, 12],
##        [13, 14, 15, 16]])
```

j) Accéder au nombre 12 dans la matrice précédente


```python
mat[2,3]
```

```
## 12
```

---

## **Chapitre 5 : Données séquentielles**
### 5.4. Les tableaux

#### Exercices interactifs (5/6)

k) Sélectionner la première ligne de la matrice


```python
#mat[0]
mat[0,:]
```

```
## array([1, 2, 3, 4])
```

l) Sélectionner la première colonne de la matrice


```python
mat[:,0]
#mat[:,0:1]
```

```
## array([ 1,  5,  9, 13])
```

m) Sélectionner une partie de la matrice contenant les nombres 11, 12, 15 et 16


```python
mat[2:,2:]
```

```
## array([[11, 12],
##        [15, 16]])
```

---

## **Chapitre 5 : Données séquentielles**
### 5.4. Les tableaux

#### Exercices interactifs (6/6)
n) Calculer la somme de toutes les valeurs de la matrice


```python
mat.sum()
```

```
## 136
```

o) Effectuer la somme de toutes les lignes de la matrices


```python
mat.sum(axis=1)
```

```
## array([10, 26, 42, 58])
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>

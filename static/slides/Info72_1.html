<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Informatique</title>
    <meta charset="utf-8" />
    <meta name="author" content="Pascal Houba" />
    <link href="Info72_1_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="Info72.css" type="text/css" />
    <link rel="stylesheet" href="Info72-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: left, middle, title-slide

# Informatique
## 2020-2021
### Pascal Houba
### <strong>Ch. 1 : Introduction aux langages de programmation</strong>

---

class:middle

### **Introduction : Une brève histoire de l’informatique**
### **Prologue : Les systèmes de numération**
### Chapitre 1 : Introduction aux langages de programmation
### **Chapitre 2 : Premiers pas en Python**
### **Chapitre 3 : Structures conditionnelles**
### **Chapitre 4 : Structures répétitives (1)**
### **Chapitre 5 : Données composites**
### **Chapitre 6 : Structures répétitives (2)**

---

## **Chapitre 1 : Introduction aux langages de programmation**
### 1.1. Références
**Manuel** : «&amp;nbsp;Apprendre à programmer avec Python 3&amp;nbsp;» de Gérard Swinnen (ULg, 2012)

La version numérique de ce texte peut être téléchargée librement à partir du site :

.center[[http://inforef.be/swi/python.htm](http://inforef.be/swi/python.htm)]

Sauf exception, les éléments suivants de la présentation sont extraites de ce manuel
(éventuellement très légèrement adaptés).

---

## **Chapitre 1 : Introduction aux langages de programmation**
### 1.2. Qu’est-ce qu’un langage de programmation **(1/3)**

La programmation d’un ordinateur consiste à «&amp;nbsp;expliquer&amp;nbsp;» en détail à une machine ce qu’elle doit faire, en sachant d’emblée qu’elle ne peut pas véritablement «&amp;nbsp;comprendre&amp;nbsp;» un langage humain, mais seulement effectuer **un traitement automatique sur des séquences de caractères**.

Il s’agit la plupart du temps de convertir un souhait exprimé à l’origine en termes «&amp;nbsp;magiques&amp;nbsp;», en un vrai raisonnement parfaitement structuré et élucidé dans ses moindres détails, que l’on appelle un **algorithme**.

Le seul «&amp;nbsp;langage&amp;nbsp;» que l’ordinateur puisse véritablement «&amp;nbsp;comprendre&amp;nbsp;» est une longue suite
de 1 et de 0 (les «&amp;nbsp;**bits**&amp;nbsp;») souvent traités par groupes de 8 (les «&amp;nbsp;**octets**&amp;nbsp;»).
Ce «&amp;nbsp;**langage machine**&amp;nbsp;» est évidemment presque incompréhensible pour nous.

On appellera **langage de programmation** un ensemble de **mots-clés** associé à un ensemble de **règles** très précises indiquant comment assembler ces mots pour former des «&amp;nbsp;phrases&amp;nbsp;» que l’**interpréteur** ou le **compilateur** (systèmes de traduction automatiques) puisse traduire en langage machine.

---

## **Chapitre 1 : Introduction aux langages de programmation**
### 1.2. Qu’est-ce qu’un langage de programmation **(2/3)**

Suivant son **niveau d’abstraction**, on pourra dire d’un langage qu’il est

 - «&amp;nbsp;**de bas niveau**&amp;nbsp;» (ex : assembleur) : il est constitué d’instructions très élémentaires, très «&amp;nbsp;proches de la machine&amp;nbsp;».

 - ou «&amp;nbsp;**de haut niveau**&amp;nbsp;» (ex : BASIC, C, Java, PHP, Python…) : il comporte des instructions plus abstraites, plus «&amp;nbsp;puissantes&amp;nbsp;», qui peuvent être traduites par l’interpréteur ou le compilateur en un grand nombre d’instructions machine élémentaires.

Les avantages que présentent les langages de haut niveau sont énormes :

 - l’écriture du programme prend beaucoup moins de temps ;

 - la probabilité d’y faire des fautes est nettement plus faible;

 - la maintenance et la recherche des erreurs (les «&amp;nbsp;bogues&amp;nbsp;») sont grandement facilitées.

---

## **Chapitre 1 : Introduction aux langages de programmation**
### 1.2. Qu’est-ce qu’un langage de programmation **(3/3)**

Un programme écrit dans un langage de haut niveau sera souvent **portable**, c’est-à-dire que l’on pourra le faire fonctionner sans guère de modifications sur des machines ou des systèmes d’exploitation différents.

Un programme écrit dans un langage de bas niveau ne peut jamais fonctionner que sur un seul type de machine : pour qu’une autre l’accepte, il faut le réécrire entièrement.

---

## **Chapitre 1 : Introduction aux langages de programmation**
### 1.3. Edition du code source

Le programme tel que nous l’écrivons dans un langage de programmation quelconque est à strictement parler un **simple texte**. Le texte ainsi produit est ce que nous appellerons désormais un **code source**. Celui-ci doit être traduit en une suite d’instructions binaires directement compréhensibles par la machine : le «&amp;nbsp;**code objet**&amp;nbsp;».

Pour rédiger ce texte, on peut faire appel à toutes sortes de logiciels plus ou moins perfectionnés, à la condition qu’ils ne produisent que du **texte brut**, c’est-à-dire sans mise en page particulière ni aucun attribut de style (pas de spécification de police, donc, pas de gros titres, pas de gras, ni de souligné, ni d’italique, etc.).

Ces logiciels sont appelés des **éditeurs de texte**. Même s’ils proposent divers automatismes, et sont souvent capables de mettre en évidence certains éléments du texte traité (coloration syntaxique, par exemple), ils ne produisent strictement que du **texte non formaté**.

Ils sont donc assez différents des logiciels de **traitement de texte**, dont la fonction consiste justement à mettre en page et à ornementer un texte avec des attributs de toute sorte.

---

## **Chapitre 1 : Introduction aux langages de programmation**
### 1.4. Recherche des erreurs

Les erreurs de programmation s’appellent des «&amp;nbsp;**bugs**&amp;nbsp;» («&amp;nbsp;bogues&amp;nbsp;» en Français), et l’ensemble des techniques misent en œuvre pour les détecter et les corriger s’appelle «&amp;nbsp;**debug**&amp;nbsp;» («&amp;nbsp;débogage&amp;nbsp;»).

Il peut exister dans un programme **trois types d’erreurs** assez différentes :

 - les **erreurs de syntaxe** produisent un arrêt de fonctionnement (un «&amp;nbsp;**plantage**&amp;nbsp;») ainsi que l’affichage d’un **message d’erreur**. La syntaxe sont les règles établies pour la structure du programme. En particulier, la **casse** (c’est-à-dire l’emploi des majuscules et des minuscules) et la **ponctuation** sont importantes.

 - les **erreurs sémantiques ou logiques** ne provoque pas d’arrêt dans l’exécution du programme ni de message d’erreur, mais conduisent à des résultats qui ne sont pas ceux attendus. En réalité, le programme fait exactement ce que vous lui avez dit de faire. Le problème est que ce que vous lui avez dit de faire ne correspond pas à ce que vous vouliez qu’il fasse.

 - les **erreurs à l’exécution** (_run-time errors_) ou **exceptions** provoquées par un événement imprévu.

---

## **Chapitre 1 : Introduction aux langages de programmation**
### 1.5. Les environnements de développement intégrés

Un **environnement de développement intégré** (_Integrated Development Environment_ ou _IDE_) est un ensemble d'outils qui permet d'augmenter la productivité des programmeurs qui développent des logiciels.

Il comporte :

 - un **éditeur de texte** destiné à la programmation,

 - des fonctions qui permettent de démarrer le **compilateur**

 - ainsi qu'un **débogueur**, qui permet d'exécuter ligne par ligne le programme en cours de construction.

 - Ils peuvent consister en un logiciel spécifique installé sur la machine de développement (par exemple Microsoft Visual Studio, Eclipse, RStudio, …), ou s’exécuter dans un navigateur (_cloud-based IDE_).

---

## **Chapitre 1 : Introduction aux langages de programmation**
### 1.6. Notebook et Markdown

Plus récemment, un nouveau format hybride de code appelé **notebook** est devenu très populaire, notamment pour les **data science**.

Il est composé de **cellules** pouvant chacune contenir :

 - soit du code source dans un langage de programmation traditionnel comme **Python**;

 - soit du texte dont la mise en forme est encodée dans un langage spécifique, le **Markdown**.

 ***

#### Liens utiles pour le Markdown

 - Un guide pour bien commencer avec markdown :

 https://blog.wax-o.com/2014/04/tutoriel-un-guide-pour-bien-commencer-avec-markdown/

 - Écrire tout simplement – Introduction à Markdown :

 http://www.boiteaoutils.info/2013/02/ecrire-tout-simplement-introduction/


---

## **Chapitre 1 : Introduction aux langages de programmation**
### 1.7. Python

Il s’agit d’un langage de programmation créé en 1991 par Guido van Rossum.

Depuis la version 2.1 sortie en 2001, le langage est détenu par l’association sans but lucratif **Python Software Foundation** (_PSF_).

Une nouvelle version majeure, **Python 3**, incompatible avec la version 2, est sortie en 2008.

Un grand nombre **bibliothèques** (_libraries_ ou _packages_) permettent d’étendre les fonctionnalités du langage de base (_core_).
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
